# Structural Design Patterns

Structural design patterns explain how to assemble objects and classes into larger structures, while keeping these structures flexible and efficient.

* [**Adapter**](./Adapter/)

  ![adapter.png](./img/adapter.png)

  Allows objects with incompatible interfaces to collaborate.

* [**Bridge**](./AbstractFactory/)

  ![bridge.png](./img/bridge.png)

  Lets you split a large class or a set of closely related classes into two separate hierarchies—abstraction and implementation—which can be developed independently of each other.

* [**Composite**](./Composite/)

  ![composite.png](./img/composite.png)

  Lets you compose objects into tree structures and then work with these structures as if they were individual objects.

* [**Decorator**](./Decorator/)

  ![decorator.png](./img/decorator.png)

  Lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors.

* [**Facade**](./Facade/)

  ![facade.png](./img/facade.png)

  Provides a simplified interface to a library, a framework, or any other complex set of classes.

* [**Flyweight**](./Flyweight/)

  ![flyweight.png](./img/flyweight.png)

  Lets you fit more objects into the available amount of RAM by sharing common parts of state between multiple objects instead of keeping all of the data in each object.
  
* [**Proxy**](./Proxy/)

  ![proxy.png](./img/proxy.png)

  Lets you provide a substitute or placeholder for another object. A proxy controls access to the original object, allowing you to perform something either before or after the request gets through to the original object.